{"files":[{"path":["/","Users","returniflost","rust-log-filter","tools","broken-tests","src","lib.rs"],"content":"//! Test crate with intentional compilation errors and warnings\n//! Used for benchmarking cargo check vs cargo chec output\n\n// ============================================\n// WARNINGS: Unused imports (5 warnings)\n// ============================================\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::fmt::Debug;\nuse std::io::Read;\nuse std::io::Write;\n\npub mod tests;\n\n// ============================================\n// WARNINGS: Unused variables (10 warnings)\n// ============================================\npub fn function_with_unused_variables() {\n    let unused_var_1 = 42;\n    let unused_var_2 = \"hello\";\n    let unused_var_3 = true;\n    let unused_var_4 = 3.14;\n    let unused_var_5 = vec![1, 2, 3];\n    let unused_var_6 = Some(42);\n    let unused_var_7 = None::<i32>;\n    let unused_var_8 = (1, 2, 3);\n    let unused_var_9 = [1, 2, 3, 4, 5];\n    let unused_var_10 = String::from(\"unused\");\n}\n\n// ============================================\n// WARNINGS: Dead code - unused functions (3 warnings)\n// ============================================\nfn unused_helper_function_1() -> i32 {\n    42\n}\n\nfn unused_helper_function_2() -> String {\n    String::from(\"never called\")\n}\n\nfn unused_helper_function_3(x: i32, y: i32) -> i32 {\n    x + y\n}\n\n// ============================================\n// WARNINGS: Unused mut (2 warnings)\n// ============================================\npub fn function_with_unused_mut() {\n    let mut unnecessary_mut_1 = 10;\n    let mut unnecessary_mut_2 = String::new();\n    println!(\"{} {}\", unnecessary_mut_1, unnecessary_mut_2);\n}\n\n// ============================================\n// WARNINGS: Non-snake case names (2 warnings)\n// ============================================\npub fn BadlyNamedFunction() {\n    let BadlyNamedVariable = 42;\n    println!(\"{}\", BadlyNamedVariable);\n}\n\n// ============================================\n// WARNINGS: Non-camel case type (2 warnings)\n// ============================================\npub struct badly_named_struct {\n    pub field: i32,\n}\n\npub enum badly_named_enum {\n    Variant1,\n    Variant2,\n}\n\n// ============================================\n// ERROR 1: Type mismatch - assigning String to i32\n// ============================================\npub fn type_mismatch_error_1() -> i32 {\n    let x: i32 = String::from(\"not a number\");\n    x\n}\n\n// ============================================\n// ERROR 2: Type mismatch - assigning bool to String\n// ============================================\npub fn type_mismatch_error_2() -> String {\n    let s: String = true;\n    s\n}\n\n// ============================================\n// ERROR 3: Unresolved import\n// ============================================\nuse nonexistent_crate::NonexistentType;\n\n// ============================================\n// ERROR 4: Missing trait implementation\n// ============================================\npub struct NoDisplayTrait {\n    data: Vec<u8>,\n}\n\npub fn missing_trait_impl() {\n    let obj = NoDisplayTrait { data: vec![] };\n    println!(\"{}\", obj);\n}\n\n// ============================================\n// ERROR 5: Method not found\n// ============================================\npub fn method_not_found() {\n    let s = String::from(\"hello\");\n    s.nonexistent_method();\n}\n\n// ============================================\n// ERROR 6: Missing required field in struct\n// ============================================\npub struct RequiredFields {\n    pub field1: i32,\n    pub field2: String,\n    pub field3: bool,\n}\n\npub fn missing_field_error() -> RequiredFields {\n    RequiredFields {\n        field1: 42,\n        // missing field2 and field3\n    }\n}\n\n// ============================================\n// ERROR 7: Wrong number of arguments\n// ============================================\npub fn takes_three_args(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}\n\npub fn wrong_arg_count() -> i32 {\n    takes_three_args(1, 2)\n}\n\n// ============================================\n// ERROR 8: Incompatible types in binary operation\n// ============================================\npub fn incompatible_binary_op() -> i32 {\n    let a = 42;\n    let b = \"string\";\n    a + b\n}\n\n// ============================================\n// ERROR 9: Unresolved variable\n// ============================================\npub fn unresolved_variable() -> i32 {\n    completely_undefined_variable\n}\n\n// ============================================\n// ERROR 10: Return type mismatch\n// ============================================\npub fn return_type_mismatch() -> bool {\n    42\n}\n\n// ============================================\n// ERROR 11: Mismatched types in match arms\n// ============================================\npub fn mismatched_match_arms(x: i32) -> i32 {\n    match x {\n        0 => 0,\n        1 => \"one\",\n        _ => 2,\n    }\n}\n\n// ============================================\n// ERROR 12: Cannot find type\n// ============================================\npub fn uses_undefined_type() -> UndefinedType {\n    UndefinedType::new()\n}\n\n// ============================================\n// Additional warnings: Unreachable code (2 warnings)\n// ============================================\npub fn unreachable_code_warning() -> i32 {\n    return 42;\n    let unreachable = 100;\n    unreachable\n}\n\npub fn another_unreachable() {\n    panic!(\"always panics\");\n    println!(\"this will never print\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","returniflost","rust-log-filter","tools","broken-tests","src","tests.rs"],"content":"// Test error suite for benchmarking cargo-tes\n// Contains various test failures for meaningful benchmarking\n\n#[cfg(test)]\nmod tests {\n    // Passing tests (should be filtered out)\n    #[test]\n    fn test_passing_simple() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_passing_complex() {\n        let mut vec = vec![1, 2, 3];\n        vec.push(4);\n        assert_eq!(vec.len(), 4);\n    }\n\n    // Failing tests with short messages\n    #[test]\n    fn test_failing_assert_eq() {\n        assert_eq!(2 + 2, 5);\n    }\n\n    #[test]\n    fn test_failing_assert() {\n        assert!(false);\n    }\n\n    #[test]\n    fn test_failing_panic_short() {\n        panic!(\"short panic\");\n    }\n\n    // Failing tests with long messages (to test space minimization)\n    #[test]\n    fn test_failing_panic_long() {\n        panic!(\"This is a very long error message that contains multiple sentences and should be properly minimized by splitting on whitespace and joining back together to reduce the overall character count in the output while preserving readability for editors and AI tools.\");\n    }\n\n    #[test]\n    fn test_failing_assert_long() {\n        let expected = \"This is a long expected string with lots of words\";\n        let actual = \"This is a long actual string with different words\";\n        assert_eq!(expected, actual, \"Custom message with additional details about why this test failed and what was expected versus what was received in the test execution.\");\n    }\n\n    // Ignored tests (filtered out as \"warnings\")\n    #[test]\n    #[ignore]\n    fn test_ignored_simple() {\n        assert_eq!(1 + 1, 3);\n    }\n\n    #[test]\n    #[ignore]\n    fn test_ignored_with_reason() {\n        // This test is ignored for benchmarking purposes\n        panic!(\"ignored panic\");\n    }\n\n    // Tests that panic with backtraces\n    #[test]\n    fn test_failing_backtrace() {\n        let vec = vec![1, 2, 3];\n        vec[10]; // Index out of bounds\n    }\n\n    // Tests with custom messages\n    #[test]\n    fn test_failing_custom_message() {\n        assert!(\n            false,\n            \"Custom failure message for testing output formatting\"\n        );\n    }\n\n    // Additional passing tests for dilution\n    #[test]\n    fn test_passing_another() {\n        assert!(true);\n    }\n\n    #[test]\n    fn test_passing_third() {\n        let x = 42;\n        assert_eq!(x * 2, 84);\n    }\n\n    // Tests with output to verify --nocapture capturing\n    #[test]\n    fn test_failing_with_stdout() {\n        println!(\"STDOUT: This is normal output from failing test\");\n        println!(\"STDOUT: Multiple lines of output\");\n        println!(\"STDOUT: Should be captured by --nocapture\");\n        assert_eq!(2 + 2, 5, \"Intentional failure to trigger output\");\n    }\n\n    #[test]\n    fn test_failing_with_stderr() {\n        eprintln!(\"STDERR: This is error output from failing test\");\n        eprintln!(\"STDERR: Multiple error lines\");\n        eprintln!(\"STDERR: Should also be captured\");\n        panic!(\"Intentional panic to show stderr capture\");\n    }\n\n    #[test]\n    fn test_failing_with_both_streams() {\n        println!(\"STDOUT: Normal output line 1\");\n        eprintln!(\"STDERR: Error output line 1\");\n        println!(\"STDOUT: Normal output line 2\");\n        eprintln!(\"STDERR: Error output line 2\");\n        assert!(false, \"Both stdout and stderr should be captured together\");\n    }\n\n    #[test]\n    fn test_passing_with_output() {\n        println!(\"PASSING: This output only shows with --nocapture or --show-output\");\n        eprintln!(\"PASSING: Same for stderr in passing tests\");\n        assert_eq!(1 + 1, 2);\n    }\n}\n\n/// ```\n/// This doctest will fail intentionally\n/// ```\n/// panic!(\"doctest failure\");\n#[test]\nfn doctest_placeholder() {\n    // Placeholder to ensure doctests are included\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","returniflost","rust-log-filter","tools","coverage-test","src","lib.rs"],"content":"/// Fully covered: simple addition\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n/// Fully covered: simple multiplication\npub fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}\n\n/// Only the `true` branch is tested — the `else` block has consecutive uncovered lines.\npub fn branch_example(flag: bool) -> &'static str {\n    if flag {\n        \"true branch\"\n    } else {\n        let _x = 1;\n        let _y = 2;\n        let _z = 3;\n        \"false branch\"\n    }\n}\n\n/// Only arms 0 and 1 are tested — remaining arms produce individual uncovered lines.\npub fn match_example(val: i32) -> &'static str {\n    match val {\n        0 => \"zero\",\n        1 => \"one\",\n        2 => \"two\",\n        3 => \"three\",\n        _ => \"other\",\n    }\n}\n\n/// Never called — produces 9+ consecutive uncovered lines to test range grouping.\npub fn never_called() -> i32 {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n    let e = 5;\n    let f = 6;\n    let g = 7;\n    let h = 8;\n    let i = 9;\n    a + b + c + d + e + f + g + h + i\n}\n\n/// Another fully uncovered block.\npub fn also_never_called() -> String {\n    let s = String::from(\"hello\");\n    let t = String::from(\" world\");\n    let u = format!(\"{}{}\", s, t);\n    u.to_uppercase()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n        assert_eq!(add(-1, 1), 0);\n    }\n\n    #[test]\n    fn test_multiply() {\n        assert_eq!(multiply(3, 4), 12);\n        assert_eq!(multiply(0, 100), 0);\n    }\n\n    #[test]\n    fn test_branch_true_only() {\n        assert_eq!(branch_example(true), \"true branch\");\n    }\n\n    #[test]\n    fn test_match_zero_and_one() {\n        assert_eq!(match_example(0), \"zero\");\n        assert_eq!(match_example(1), \"one\");\n    }\n}\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":2}},{"line":3,"address":[],"length":0,"stats":{"Line":2}},{"line":7,"address":[],"length":0,"stats":{"Line":2}},{"line":8,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":31},{"path":["/","Users","returniflost","rust-log-filter","tools","demo-outputs","src","lib.rs"],"content":"pub fn add(left: u64, right: u64) -> u64 {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","returniflost","rust-log-filter","tools","demo-outputs","tests","capture_tests.rs"],"content":"// Tests demonstrating --nocapture output capture with cargo tes\n\n#[test]\nfn test_failing_with_stdout() {\n    println!(\"STDOUT: This is normal output from failing test\");\n    println!(\"STDOUT: Multiple lines of output\");\n    println!(\"STDOUT: Should be captured by --nocapture\");\n    assert_eq!(2 + 2, 5, \"Intentional failure to trigger output\");\n}\n\n#[test]\nfn test_failing_with_stderr() {\n    eprintln!(\"STDERR: This is error output from failing test\");\n    eprintln!(\"STDERR: Multiple error lines\");\n    eprintln!(\"STDERR: Should also be captured\");\n    panic!(\"Intentional panic to show stderr capture\");\n}\n\n#[test]\nfn test_failing_with_both_streams() {\n    println!(\"STDOUT: Normal output line 1\");\n    eprintln!(\"STDERR: Error output line 1\");\n    println!(\"STDOUT: Normal output line 2\");\n    eprintln!(\"STDERR: Error output line 2\");\n    assert!(false, \"Both stdout and stderr should be captured together\");\n}\n\n#[test]\nfn test_passing_with_output() {\n    println!(\"PASSING: This output only shows with --nocapture or --show-output\");\n    eprintln!(\"PASSING: Same for stderr in passing tests\");\n    assert_eq!(1 + 1, 2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","returniflost","rust-log-filter","wrappers","chec","src","main.rs"],"content":"use clap::Parser;\nuse serde_json::{json, Value};\nuse std::{\n    fs,\n    io::{self, Read},\n};\n\n#[derive(Parser)]\n#[command(name = \"cargo\", bin_name = \"cargo\")]\nenum Cargo {\n    #[command(name = \"chec\")]\n    Chec(Args),\n}\n\n#[derive(clap::Args)]\n#[command(version, about = \"Filtered cargo check errors/warnings, as JSON\")]\n#[command(\n    long_about = \"Runs `cargo check --message-format=json` and transforms the output into a \\\n    simplified JSON array of error strings. Useful for CI/CD pipelines, editors, and AI tools.\\n\\n\\\n    All cargo check flags are supported and passed through (e.g. --release, --package, --all-targets).\\n\\n\\\n    Use --input to parse existing cargo check output instead of running cargo check.\"\n)]\nstruct Args {\n    /// Parse from file or stdin (\"-\") instead of running cargo check\n    #[arg(short, long, value_name = \"FILE\")]\n    input: Option<String>,\n\n    /// Arguments passed through to cargo check (e.g. --release, -p foo)\n    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]\n    cargo_args: Vec<String>,\n\n    /// Include warnings in the output\n    #[arg(long)]\n    include_warnings: bool,\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let Cargo::Chec(args) = Cargo::parse();\n\n    let (json_str, failure_opt) = match &args.input {\n        Some(p) if p == \"-\" => {\n            let mut s = String::new();\n            io::stdin().read_to_string(&mut s)?;\n            (s, None)\n        }\n        Some(p) => (fs::read_to_string(p)?, None),\n        None => {\n            let output = std::process::Command::new(\"cargo\")\n                .arg(\"check\")\n                .arg(\"--message-format=json\")\n                .args(&args.cargo_args)\n                .output()?;\n            let status = output.status;\n            let stderr = output.stderr;\n            (String::from_utf8(output.stdout)?, Some((status, stderr)))\n        }\n    };\n\n    let mut results: Vec<String> = json_str.lines()\n        .filter_map(|l| serde_json::from_str::<Value>(l).ok())\n        .filter_map(|log| {\n            let msg = log.get(\"message\").filter(|_| log[\"reason\"] == \"compiler-message\")?;\n            let (severity, label) = match msg[\"level\"].as_str()? {\n                \"error\" => (5, \"Error\"),\n                \"warning\" if args.include_warnings => (4, \"Warning\"),\n                _ => return None\n            };\n            let span = msg[\"spans\"].as_array()?.first()?;\n            let resource = span[\"file_name\"].as_str()?;\n            let (sl, sc, ec) = (span[\"line_start\"].as_i64()?, span[\"column_start\"].as_i64()?, span[\"column_end\"].as_i64()?);\n            let message: String = msg[\"rendered\"].as_str()?.split_whitespace().collect::<Vec<_>>().join(\" \");\n\n            let related: Vec<Value> = msg[\"children\"].as_array().unwrap_or(&vec![]).iter().filter_map(|c| {\n                let sp = c[\"spans\"].as_array()?.first()?;\n                Some(json!({\"message\": c[\"message\"].as_str()?, \"resource\": sp[\"file_name\"].as_str()?,\n                    \"startLineNumber\": sp[\"line_start\"], \"startColumn\": sp[\"column_start\"],\n                    \"endLineNumber\": sp[\"line_end\"], \"endColumn\": sp[\"column_end\"]}))\n            }).collect();\n\n            let mut out = format!(\"{} (severity {}) from rustc in {} at line {}:{}-{}: {}\",\n                label, severity, resource, sl, sc, ec, message);\n            for r in &related {\n                out.push_str(&format!(\" Related: In {} at line {}:{}-{}: {}\",\n                    r[\"resource\"].as_str().unwrap_or(\"\"), r[\"startLineNumber\"], r[\"startColumn\"],\n                    r[\"endColumn\"], r[\"message\"].as_str().unwrap_or(\"\").split_whitespace().collect::<Vec<_>>().join(\" \")));\n            }\n            Some(out)\n        }).collect();\n\n    if let Some((status, stderr)) = failure_opt {\n        if !status.success() {\n            results.push(format!(\n                \"Cargo check failed with exit code {}: {}\",\n                status.code().unwrap_or(-1),\n                String::from_utf8_lossy(&stderr)\n            ));\n        }\n    }\n\n    println!(\"{}\", serde_json::to_string(&results)?);\n    Ok(())\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","returniflost","rust-log-filter","wrappers","tes","src","main.rs"],"content":"use clap::Parser;\nuse serde_json::{json, Value};\nuse std::{\n    fs,\n    io::{self, BufRead, BufReader, Read, Write},\n    process::{Command, Stdio},\n    thread,\n};\n\n#[derive(Parser)]\n#[command(name = \"cargo\", bin_name = \"cargo\")]\nenum Cargo {\n    #[command(name = \"tes\")]\n    Tes(TestArgs),\n}\n\n#[derive(clap::Args)]\n#[command(version, about = \"Filtered cargo test failures, as JSON\")]\n#[command(\n    long_about = \"Runs `cargo test --message-format=json -- --format=json` and transforms the output into a \\\n    simplified JSON array of test failure strings. Useful for CI/CD pipelines, editors, and AI tools.\\n\\n\\\n    All cargo test flags are supported and passed through (e.g. --release, --package, --all-targets).\\n\\n\\\n    Use --input to parse existing cargo test output instead of running cargo test.\"\n)]\nstruct TestArgs {\n    /// Parse from file or stdin (\"-\") instead of running cargo test\n    #[arg(short, long, value_name = \"FILE\")]\n    input: Option<String>,\n\n    /// Arguments passed through to cargo test (e.g. --release, -p foo)\n    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]\n    cargo_args: Vec<String>,\n\n    /// Include ignored tests in the output as warnings\n    #[arg(long)]\n    include_ignored: bool,\n}\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let Cargo::Tes(args) = Cargo::parse();\n\n    let (json_str, failure_status) = match &args.input {\n        Some(p) if p == \"-\" => {\n            let mut s = String::new();\n            io::stdin().read_to_string(&mut s)?;\n            (s, None)\n        }\n        Some(p) => (fs::read_to_string(p)?, None),\n        None => {\n            // Split args: cargo flags before '--', test flags after\n            let (cargo_flags, test_flags): (Vec<_>, Vec<_>) = args.cargo_args.iter()\n                .partition(|arg| !arg.starts_with(\"--nocapture\") && !arg.starts_with(\"--show-output\"));\n\n            let mut child = Command::new(\"cargo\")\n                .arg(\"test\")\n                .arg(\"--message-format=json\")\n                .args(cargo_flags)\n                .arg(\"--\")\n                .arg(\"-Z\")\n                .arg(\"unstable-options\")\n                .arg(\"--format=json\")\n                .args(test_flags)\n                .env(\"CARGO_TERM_COLOR\", \"always\")\n                .stdout(Stdio::piped())\n                .stderr(Stdio::piped())\n                .spawn()?;\n\n            // Take ownership of stderr for streaming in a separate thread\n            let stderr = child.stderr.take().expect(\"capture stderr\");\n            let stderr_handle = thread::spawn(move || {\n                for line in BufReader::new(stderr).lines().map_while(Result::ok) {\n                    if !line.trim().starts_with(\"Running \") {\n                        let _ = writeln!(io::stderr(), \"{}\", line);\n                    }\n                }\n            });\n            let stdout: Vec<_> = BufReader::new(child.stdout.take().expect(\"capture stdout\"))\n                .lines()\n                .map_while(Result::ok)\n                .collect();\n            let status = child.wait()?;\n            let _ = stderr_handle.join();\n            let json_str = stdout.join(\"\\n\");\n            (json_str, Some(status))\n        }\n    };\n\n    let mut results: Vec<String> = json_str.lines()\n        .filter_map(|l| serde_json::from_str::<Value>(l).ok())\n        .filter_map(|log| {\n            // Handle compiler messages (same as check)\n            if let Some(msg) = log.get(\"message\").filter(|_| log[\"reason\"] == \"compiler-message\") {\n                let (severity, label) = match msg[\"level\"].as_str()? {\n                    \"error\" => (5, \"Error\"),\n                    \"warning\" if args.include_ignored => (4, \"Warning\"), // Note: treating warnings as optional\n                    _ => return None\n                };\n                let span = msg[\"spans\"].as_array()?.first()?;\n                let resource = span[\"file_name\"].as_str()?;\n                let (sl, sc, ec) = (span[\"line_start\"].as_i64()?, span[\"column_start\"].as_i64()?, span[\"column_end\"].as_i64()?);\n                let message: String = msg[\"rendered\"].as_str()?.split_whitespace().collect::<Vec<_>>().join(\" \");\n\n                let related: Vec<Value> = msg[\"children\"].as_array().unwrap_or(&vec![]).iter().filter_map(|c| {\n                    let sp = c[\"spans\"].as_array()?.first()?;\n                    Some(json!({\"message\": c[\"message\"].as_str()?, \"resource\": sp[\"file_name\"].as_str()?,\n                        \"startLineNumber\": sp[\"line_start\"], \"startColumn\": sp[\"column_start\"],\n                        \"endLineNumber\": sp[\"line_end\"], \"endColumn\": sp[\"column_end\"]}))\n                }).collect();\n\n                let mut out = format!(\"{} (severity {}) from rustc in {} at line {}:{}-{}: {}\",\n                    label, severity, resource, sl, sc, ec, message);\n                for r in &related {\n                    out.push_str(&format!(\" Related: In {} at line {}:{}-{}: {}\",\n                        r[\"resource\"].as_str().unwrap_or(\"\"), r[\"startLineNumber\"], r[\"startColumn\"],\n                        r[\"endColumn\"], r[\"message\"].as_str().unwrap_or(\"\").split_whitespace().collect::<Vec<_>>().join(\" \")));\n                }\n                Some(out)\n            } else if log[\"type\"] == \"test\" && log[\"event\"] == \"failed\" {\n                // Handle failed tests\n                let name = log[\"name\"].as_str()?;\n                let exec_time = log[\"exec_time\"].as_f64().unwrap_or(0.0);\n                let stdout = log[\"stdout\"].as_str().unwrap_or(\"\").split_whitespace().collect::<Vec<_>>().join(\" \");\n                Some(format!(\"Test failed: {} (exec_time: {:.3}s) - {}\", name, exec_time, stdout))\n            } else if log[\"type\"] == \"suite\" && log[\"event\"] == \"failed\" {\n                // Handle failed suites\n                let passed = log[\"passed\"].as_i64()?;\n                let failed = log[\"failed\"].as_i64()?;\n                let exec_time = log[\"exec_time\"].as_f64()?;\n                Some(format!(\"Suite failed: passed {}, failed {} (exec_time: {:.3}s)\", passed, failed, exec_time))\n            } else {\n                None\n            }\n        }).collect();\n\n    if let Some(status) = failure_status {\n        if !status.success() {\n            results.push(format!(\n                \"Cargo test failed with exit code {}\",\n                status.code().unwrap_or(-1)\n            ));\n        }\n    }\n\n    println!(\"{}\", serde_json::to_string(&results)?);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":35.483870967741936,"covered":11,"coverable":31}